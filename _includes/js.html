<!--
  Note on Subresource Integrity (SRI):
  - Local files (jQuery, Bootstrap, etc.) don't require SRI as they're same-origin
  - Google Analytics script is dynamic and changes frequently, so SRI isn't practical
  - Disqus and Twitter scripts are dynamically loaded, so SRI isn't applicable
  - Facebook SDK already includes crossorigin="anonymous" for CORS support
  - For production CDN resources, consider adding integrity attributes when possible
-->

<!-- jQuery -->
<script src="{{ site.baseurl }}/js/jquery.min.js"></script>

<!-- Bootstrap Core JavaScript -->
<script src="{{ site.baseurl }}/js/bootstrap.min.js" defer></script>

<!-- Plugin JavaScript -->
<script src="{{ site.baseurl }}/js/jquery.easing.min.js" defer></script>

<!-- Custom Theme JavaScript -->
<script src="{{ site.baseurl }}/js/grayscale.min.js" defer></script>

<!-- WebP Background Image Support -->
<script>
(function() {
  // Detect WebP support
  function supportsWebP() {
    var canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas.toDataURL('image/webp').indexOf('data:image/webp') === 0;
  }
  
  // Update background images to WebP if supported
  if (supportsWebP()) {
    var styleSheets = document.styleSheets;
    for (var i = 0; i < styleSheets.length; i++) {
      try {
        var rules = styleSheets[i].cssRules || styleSheets[i].rules;
        for (var j = 0; j < rules.length; j++) {
          var rule = rules[j];
          if (rule.style && rule.style.backgroundImage) {
            var bgImage = rule.style.backgroundImage;
            // Replace .jpg and .png with .webp in background images
            if (bgImage.indexOf('.jpg') !== -1 || bgImage.indexOf('.png') !== -1) {
              rule.style.backgroundImage = bgImage.replace(/\.(jpg|png)/g, '.webp');
            }
          }
        }
      } catch (e) {
        // Cross-origin stylesheets may throw errors, skip them
      }
    }
    
    // Also update inline styles and elements with background-image
    var elements = document.querySelectorAll('[style*="background"]');
    elements.forEach(function(el) {
      var style = el.getAttribute('style');
      if (style && (style.indexOf('.jpg') !== -1 || style.indexOf('.png') !== -1)) {
        el.setAttribute('style', style.replace(/\.(jpg|png)/g, '.webp'));
      }
    });
  }
})();
</script>

{% if site.google-tracking-id %}
  <!-- Google tag (gtag.js) - Google Analytics 4 -->
  <!-- Note: SRI not practical for GA scripts as they change frequently -->
  <script async src="https://www.googletagmanager.com/gtag/js?id={{ site.google-tracking-id }}" crossorigin="anonymous"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', '{{ site.google-tracking-id }}');
  </script>
{% endif %}

{% if page.section-type == "post" %}

  <!-- Share buttons -->

  {% if site.twitter-share %}
    <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  {% endif %}

  {% if site.fb-share and site.fb-app-id %}
    <div id="fb-root"></div>
    <script async defer crossorigin="anonymous" src="https://connect.facebook.net/en_US/sdk.js#xfbml=1&version=v18.0&appId={{ site.fb-app-id }}&autoLogAppEvents=1"></script>
  {% elsif site.fb-share %}
    <!-- Facebook SDK disabled: fb-app-id not configured in _config.yml -->
  {% endif %}

  <!-- Disqus -->

  {% if site.disqus-shortname %}
    <script>
    var disqus_shortname = '{{ site.disqus-shortname }}';
    (function() {
        var dsq = document.createElement('script'); dsq.async = true;
        dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
  {% endif %}

{% endif %}

{% if page.section-type == "post" or page.section-type == "blog" or page.section-type == "index" or page.section-type == "tag" %}

  <!-- Comments counter -->

  <script>
  /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
  var disqus_shortname = '{{ site.disqus-shortname }}'; // required: replace example with your forum shortname

  /* * * DON'T EDIT BELOW THIS LINE * * */
  (function () {
  var s = document.createElement('script'); s.async = true;
  s.src = 'https://' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
  }());
  </script>
{% endif %}

<!-- Avatar Click Emoji Effect -->
<script>
(function() {
  // Emojis related to Mati's interests and background
  var emojis = ['üß†', 'üì±', 'üçé', 'ü§ñ', 'üßä', 'üî≠', 'üíª', 'üöÄ', 'üåü', '‚ö°'];
  
  // Black hole variables (will be initialized when DOM is ready)
  var blackHoleX = 20 + 30; // left + radius
  var blackHoleY = 0;
  var blackHoleRadius = 30;
  var blackHolePullRadius = 200; // Distance at which emojis start getting pulled
  var cursorNearBlackHole = false;
  var emojiCount = 0; // Counter for consumed emojis
  
  // Create black hole and counter when DOM is ready
  function createBlackHole() {
    if (document.body) {
      // Check if black hole already exists
      if (!document.getElementById('black-hole')) {
        // Create black hole at bottom left - make it more visible
        var blackHole = document.createElement('div');
        blackHole.id = 'black-hole';
        blackHole.style.cssText = 'position:fixed;bottom:20px;left:20px;width:60px;height:60px;border-radius:50%;background:radial-gradient(circle, #000 0%, #1a1a2e 70%, #2a2a4e 100%);box-shadow:0 0 40px rgba(0,0,0,0.9), inset 0 0 30px rgba(0,0,0,0.95), 0 0 10px rgba(26,77,122,0.3);z-index:2;pointer-events:none;border:2px solid rgba(26,77,122,0.4);';
        document.body.appendChild(blackHole);
      }
      
      // Check if counter already exists
      if (!document.getElementById('black-hole-counter')) {
        // Create counter above black hole
        var blackHoleCounter = document.createElement('div');
        blackHoleCounter.id = 'black-hole-counter';
        blackHoleCounter.style.cssText = 'position:fixed;bottom:90px;left:20px;width:60px;text-align:center;color:#1a4d7a;font-size:18px;font-weight:bold;z-index:2;pointer-events:none;font-family:Montserrat,sans-serif;text-shadow:0 0 5px rgba(26,77,122,0.5);';
        blackHoleCounter.textContent = emojiCount.toString();
        document.body.appendChild(blackHoleCounter);
        console.log('Black hole counter created with count:', emojiCount);
      } else {
        // Update existing counter
        var existingCounter = document.getElementById('black-hole-counter');
        existingCounter.textContent = emojiCount.toString();
      }
      
      // Update black hole Y position
      blackHoleY = window.innerHeight - 20 - 30;
      
      // Track cursor position relative to black hole
      document.addEventListener('mousemove', function(e) {
        var dx = e.clientX - blackHoleX;
        var dy = e.clientY - blackHoleY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        cursorNearBlackHole = distance < blackHolePullRadius;
      });
      
      // Update black hole position on window resize
      window.addEventListener('resize', function() {
        blackHoleY = window.innerHeight - 20 - 30;
        var counter = document.getElementById('black-hole-counter');
        if (counter) {
          counter.style.bottom = (window.innerHeight - 20 - 30 + 60) + 'px';
        }
      });
    }
  }
  
  // Initialize black hole when DOM is ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', createBlackHole);
  } else {
    createBlackHole();
  }
  
  // Get avatar position for orbit center
  function getAvatarPosition() {
    var avatarElement = document.getElementById('avatar-link');
    if (avatarElement) {
      var img = avatarElement.querySelector('.img-me') || avatarElement.querySelector('img');
      if (img) {
        var rect = img.getBoundingClientRect();
        return {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2
        };
      }
    }
    return { x: window.innerWidth / 2, y: window.innerHeight / 2 };
  }
  
  // Create emoji drop effect
  function createEmojiDrop(x, y) {
    var emoji = emojis[Math.floor(Math.random() * emojis.length)];
    var emojiElement = document.createElement('div');
    emojiElement.className = 'emoji-drop';
    emojiElement.textContent = emoji;
    // Set all styles inline to ensure visibility - behind text, dark blue
    emojiElement.style.cssText = 'position:fixed;font-size:30px;pointer-events:none;z-index:1;user-select:none;color:#1a4d7a;text-shadow:0 0 5px rgba(26,77,122,0.3);opacity:1;';
    emojiElement.style.left = x + 'px';
    emojiElement.style.top = y + 'px';
    document.body.appendChild(emojiElement);
    
    // Rotation
    var rotation = Math.random() * 360;
    var rotationSpeed = (Math.random() - 0.5) * 10;
    
    // Mouse position tracking
    var mouseX = 0;
    var mouseY = 0;
    var hasCursor = false;
    var cursorTrapRadius = 40; // Distance at which cursor "traps" the emoji (very close)
    
    // Get current mouse position
    var updateMousePos = function(e) {
      hasCursor = true;
      mouseX = e.clientX;
      mouseY = e.clientY;
    };
    document.addEventListener('mousemove', updateMousePos);
    
    // Try to get initial cursor position
    if (typeof window !== 'undefined') {
      var getInitialPos = function(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;
        hasCursor = true;
        document.removeEventListener('mousemove', getInitialPos);
      };
      document.addEventListener('mousemove', getInitialPos, { once: true });
    }
    
    var startTime = Date.now();
    var duration = 60000; // 60 seconds (1 minute)
    
    // Orbit parameters - random radius between two ranges around avatar
    var range1 = 100 + Math.random() * 50; // 100-150px
    var range2 = 180 + Math.random() * 50; // 180-230px
    var orbitRadius = Math.random() > 0.5 ? range1 : range2; // Randomly choose between the two ranges
    var orbitAngle = Math.random() * Math.PI * 2; // Random starting angle
    var orbitSpeed = 0.02 + Math.random() * 0.02; // Random orbit speed
    var orbitDirection = Math.random() > 0.5 ? 1 : -1; // Random direction
    
    // Orbit target (starts as avatar, can switch to cursor)
    var orbitTarget = 'avatar'; // 'avatar' or 'cursor'
    var avatarPos = getAvatarPosition();
    var beingSuckedByBlackHole = false; // Track if emoji is being sucked (should continue even if cursor moves)
    
    // Current position for lag effect
    var currentPosX = x;
    var currentPosY = y;
    var lagFactor = 0.15 + Math.random() * 0.1; // Random lag between 0.15-0.25 for variety
    
    
    function animate() {
      var elapsed = Date.now() - startTime;
      var progress = elapsed / duration;
      
      if (progress >= 1) {
        emojiElement.style.opacity = '0';
        setTimeout(function() {
          if (emojiElement.parentNode) {
            document.body.removeChild(emojiElement);
          }
          document.removeEventListener('mousemove', updateMousePos);
        }, 300);
        return;
      }
      
      // Update avatar position (in case page scrolls)
      avatarPos = getAvatarPosition();
      
      // Check if cursor is very close to trap this emoji
      if (hasCursor && orbitTarget === 'avatar') {
        var dxToCursor = mouseX - currentPosX;
        var dyToCursor = mouseY - currentPosY;
        var distanceToCursor = Math.sqrt(dxToCursor * dxToCursor + dyToCursor * dyToCursor);
        
        if (distanceToCursor < cursorTrapRadius) {
          // Cursor is very close - trap the emoji! Switch to cursor orbit
          orbitTarget = 'cursor';
          orbitRadius = 50 + Math.random() * 30; // New orbit radius around cursor
          orbitAngle = Math.atan2(dyToCursor, dxToCursor); // Start from current angle
        }
      }
      
      // Check if cursor is near black hole - only affect emojis orbiting the cursor
      // Once being sucked, continue even if cursor moves away
      if ((hasCursor && cursorNearBlackHole && orbitTarget === 'cursor') || beingSuckedByBlackHole) {
        // Mark as being sucked if cursor is near black hole
        if (hasCursor && cursorNearBlackHole && orbitTarget === 'cursor') {
          beingSuckedByBlackHole = true;
        }
        
        // Position emoji on top of black hole (centered above it)
        var targetX = blackHoleX;
        var targetY = blackHoleY - blackHoleRadius - 10; // Position above the black hole
        
        // Calculate distance to target position (above black hole)
        var dx = targetX - currentPosX;
        var dy = targetY - currentPosY;
        var distance = Math.sqrt(dx * dx + dy * dy);
        
        // Calculate distance to black hole center for scale calculation
        var dxToCenter = blackHoleX - currentPosX;
        var dyToCenter = blackHoleY - currentPosY;
        var distanceToCenter = Math.sqrt(dxToCenter * dxToCenter + dyToCenter * dyToCenter);
        
        // Calculate scale based on distance to black hole - smaller as it gets closer
        var maxPullDistance = blackHolePullRadius; // Use the pull radius as max distance
        var minScale = 0.2; // Minimum scale when very close (20% of original size)
        var maxScale = 1.0; // Maximum scale when far away
        // Scale decreases as distance decreases (closer = smaller)
        var normalizedDistance = Math.min(1, distanceToCenter / maxPullDistance);
        var scale = minScale + (maxScale - minScale) * normalizedDistance;
        
        // Update rotation
        rotation += rotationSpeed;
        emojiElement.style.transform = 'rotate(' + rotation + 'deg) scale(' + scale + ')';
        
        // Check if emoji reached the target position above black hole
        if (distance < 10) {
          // Emoji reached black hole - remove it and increment counter
          emojiCount++;
          console.log('Black hole consumed emoji! Count:', emojiCount);
          
          // Update counter immediately - try multiple approaches
          var counterEl = document.getElementById('black-hole-counter');
          if (counterEl) {
            counterEl.textContent = emojiCount.toString();
            counterEl.innerHTML = emojiCount.toString(); // Also try innerHTML
            console.log('Counter updated to:', emojiCount);
          } else {
            console.warn('Counter element not found! Searching...');
            // Try to find it again
            setTimeout(function() {
              var counterEl2 = document.getElementById('black-hole-counter');
              if (counterEl2) {
                counterEl2.textContent = emojiCount.toString();
                console.log('Counter found and updated to:', emojiCount);
              } else {
                console.error('Counter element still not found after delay');
              }
            }, 10);
          }
          
          emojiElement.style.opacity = '0';
          setTimeout(function() {
            if (emojiElement.parentNode) {
              document.body.removeChild(emojiElement);
            }
            document.removeEventListener('mousemove', updateMousePos);
          }, 100);
          return;
        }
        
        // Strong pull toward black hole position
        var pullStrength = 0.5; // Increased pull strength
        currentPosX += (targetX - currentPosX) * pullStrength;
        currentPosY += (targetY - currentPosY) * pullStrength;
        
        // Update position immediately
        emojiElement.style.left = currentPosX + 'px';
        emojiElement.style.top = currentPosY + 'px';
        
        requestAnimationFrame(animate);
        return;
      } else {
        // Orbit phase - calculate target orbit position
        orbitAngle += orbitSpeed * orbitDirection;
        
        // Determine orbit center based on current target
        var centerX, centerY;
        if (orbitTarget === 'cursor' && hasCursor) {
          centerX = mouseX;
          centerY = mouseY;
        } else {
          centerX = avatarPos.x;
          centerY = avatarPos.y;
        }
        
        // Calculate target circular position around center
        var targetX = centerX + Math.cos(orbitAngle) * orbitRadius;
        var targetY = centerY + Math.sin(orbitAngle) * orbitRadius;
        
        // Gradually reduce orbit radius over time for a spiral effect
        orbitRadius *= 0.9995;
      }
      
      // Lag effect - gradually move toward target position (chase effect)
      if (typeof targetX !== 'undefined' && typeof targetY !== 'undefined') {
        currentPosX += (targetX - currentPosX) * lagFactor;
        currentPosY += (targetY - currentPosY) * lagFactor;
      }
      
      // Rotation
      rotation += rotationSpeed;
      
      // Only update transform if not being sucked by black hole (black hole sets its own transform)
      if (!(hasCursor && cursorNearBlackHole && orbitTarget === 'cursor')) {
        emojiElement.style.transform = 'rotate(' + rotation + 'deg)';
      }
      
      emojiElement.style.left = currentPosX + 'px';
      emojiElement.style.top = currentPosY + 'px';
      emojiElement.style.opacity = (1 - progress * 0.8).toString();
      
      requestAnimationFrame(animate);
    }
    
    requestAnimationFrame(animate);
  }
  
  // Add click handler to avatar
  function initAvatarEmoji() {
    // Try multiple ways to find the avatar
    var avatarElement = document.getElementById('avatar-link');
    
    if (!avatarElement) {
      // Try finding by the image class
      var img = document.querySelector('.intro .img-me');
      if (img) {
        // Go up to find the container (could be picture or div)
        avatarElement = img.closest('div') || img.parentElement;
      }
    }
    
    // Also try finding the picture element
    if (!avatarElement) {
      var picture = document.querySelector('.intro picture');
      if (picture) {
        avatarElement = picture.parentElement;
      }
    }
    
    if (avatarElement) {
      console.log('‚úÖ Avatar emoji effect: Found avatar element');
      
      // Check if handler already attached
      if (avatarElement.dataset.emojiHandlerAttached) {
        console.log('Handler already attached, skipping');
        return;
      }
      avatarElement.dataset.emojiHandlerAttached = 'true';
      
      avatarElement.addEventListener('click', function(e) {
        console.log('üéØ Avatar clicked!');
        e.stopPropagation();
        try {
          // Find the actual image element
          var img = this.querySelector('.img-me') || this.querySelector('img');
          var element = img || this;
          var rect = element.getBoundingClientRect();
          var centerX = rect.left + rect.width / 2;
          var centerY = rect.top + rect.height / 2;
          
          console.log('üìç Creating emoji at:', centerX, centerY);
          
          // Create only 1 random emoji per click
          createEmojiDrop(centerX, centerY);
          console.log('‚ú® Emoji created!');
        } catch (err) {
          console.error('‚ùå Emoji effect error:', err);
        }
      }, false);
    } else {
      console.warn('‚ö†Ô∏è Avatar emoji effect: Could not find avatar element');
      console.log('Available elements:', {
        avatarLink: document.getElementById('avatar-link'),
        imgMe: document.querySelector('.intro .img-me'),
        picture: document.querySelector('.intro picture')
      });
    }
  }
  
  // Initialize everything when DOM is ready
  function initEverything() {
    createBlackHole();
    initAvatarEmoji();
  }
  
  // Wait for DOM to be ready
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initEverything);
  } else {
    // DOM already ready
    setTimeout(initEverything, 100);
  }
  
  // Also try on window load as backup
  window.addEventListener('load', function() {
    setTimeout(function() {
      if (!document.getElementById('black-hole')) {
        createBlackHole();
      }
      if (!document.getElementById('avatar-link') || !document.querySelector('.intro .img-me')) {
        // Element not found yet, try again
        setTimeout(initAvatarEmoji, 200);
      }
    }, 100);
  });
})();
</script>
